# 数据结构：图2

# 拓扑排序：

### 基本思路和代码实现：

1. 定义一个队列，并把所有入度为0的结点加入队列
2. 取队首结点，输出。然后删去从它出发的所有边，并令这些边到达的顶点的入度减1，如果某个顶点的入度为0，则将其加入队列。
3. 反复进行2操作，直到队列为空为止。如果队列为空的时候入过队的结点数目恰好为N，说明，拓扑排序成功，否则拓扑排序失败，图中有环。

```c++
vector<int> g[maxn];//邻接表
int n,m,inDegree[maxn];//顶点数，入度
//拓扑排序
bool topologicalSort(){
    int num=0;//记录加入拓扑排序的顶点
    queue<int> q;
    for(iny i=0;i<n;i++){
        if(inDegreee[i]==0)
            q.push(i);//将所有入度为0的顶点入队
    }
    while(!q.empty()){
        int u=q.front();
        //cout<<u; //此处可以输出顶点，作为拓扑序列中的顶点
        q.pop();
        for(int i=0;i<g[u].size();i++){
            int v=g[u][i];
            inDegree[v]--;//顶点v的入度减1
            if(inDegree[v]==0){
                q.push(v);
            }
        }
        g[u].clear() //清空顶点u的所有出边
        num++; //加入拓扑序列的顶点数加1
    }
    if(num==n) return true; //拓扑排序成功
    else return false; //拓扑排序失败
}
```

