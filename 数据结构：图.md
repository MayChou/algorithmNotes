# 数据结构：图

### 1. 图的存储

邻接矩阵：
利用二维数组来存储。

邻接表：

```c++
//不需要存储边的权值
vector<int> Adj[N];
//如果需要添加一条从1号顶点到3号顶点的有向边
Adj[1].push_back(3);

//需要同时存放边的终点编号和权值
struct node{
    int v;//边的终点编号
    int w;//边权
}
vector<Node> Adj[N];
//如果需要添加从1号到达3号顶点的有向边，边权为4
Node temp;
temp.v=3;
temp.w=4;Adj[1].push_back(temp);

//更快的方法是定义结构体构造函数
struct Node{
    int v,w;
    Node(int _v,int _w):v(_v),w(_w){}//构造函数
}
//这样就可以不定义临时变量来实现加边的操作：
Adj[1].push_back(Node(3,4));
```

### 2. 图的遍历

**深度优先搜索(DFS)遍历图：**

如果给定的图是一个连通图，则只需要一次DFS就可以完成遍历

```c++
//伪代码
DFS(u){
    vis[u]=true;//设置U已经被访问过
    for(从u出发能到达的所有顶点v){
        if vis[v]==false//如果v没有被访问过
        	DFS(V);
    }
}
DFSTrave(G){
    for(G的所有顶点u)//对G的所有顶点u
        if(vis[u]==false)
            DFS(u);
}
```

邻接矩阵版：

```c++
const int MAXV=1000;//最大顶点数
const int INF=100000000;
int n,G[MAXV][MAXV];
bool vis[MAXV]={false};

void DFS(int u,int depth){
    vis[u]=true;//设置u为已经被访问
    //如果需要对u进行操作，在这里进行
    for(int v=0;v<n;v++){
        if(vis[v]==false&&G[u][v]!=TNF){
            DFS(v,depth+1);
        }
    }
}

void DFSTrave(){
    for(int u=0;u<n;u++){
        if(vis[u]==false){
            DFS(u,1);
        }
    }
}
```

邻接表版：

```c++
vector<int> Adj[MAXv];
int n;
bool vis[MAXV]={false};
void DFS(int u,int depth){
    vis[u]=true;
    for(int i=0;i<Adj[u].size();i++){
        int v=Adj[u][i];
        if(vis[v]==false){//如果v未被访问
            DFS(v,depth+1);
        }
    }
}

void DFSTrave(){
    for(int u-0;u<n;u++){
        if(vis[u]==false){
            DFS(u,1);
        }
    }
}
```



**采用广度优先搜索（BFS）法遍历图**：

```c++
//BFS伪代码
BFS(u){
    queue q;
    将u入队;
    inq[u]=true;
    while(!q.empty()){
        取出q的队首元素进行访问;
        for(从u出发可达的所有顶点v){
            if(inq(v)==false){
                将v入队；
                inq[v]=true;
            }
        }
    }
}

BFSTrave(G){
    for(G的所有顶点u){
        if(inq[u]==false){
            BFS(u);
        }
	}
}
```

邻接矩阵版：

```c++
int n,G[maxn][maxn];
bool inq[maxn]={false};

void BFS(int u){
    queue<int> q;
    q.push(u);
    inq[u]=true;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int v=0;v<n;v++){
            if(inq[v]==false&&G[u][v]!=INF){
                q,push(v);
                int[v]=true;
            }
        }
    }
}

void BFSTrave(){
    for(int u=0;u<n;u++){
        if(inq[u]==false){
            BFS(q);
        }
    }
}
```

邻接表版：

```c++
vector<int> Adj[maxn];
int n;//顶点数
boolinq[maxn]={false};

void BFS(int u){
    queue<int> q;
    q.push(u);
    inq[u]=true;
    while(!q.empty()){
        int u=q.front();
        q.pop();
        for(int i=0;i<Adj[u].size();i++){
            int v=Adj[u][i];
            if(inq[v]==false){
                q,push(v);
                inq[v]=true;
            }
        }
    }
}

void BFSTrave(){
    for(int u=0;u<n;u++){
        if(inq[u]==false){
            BFS(u);
        }
    }
}
```

