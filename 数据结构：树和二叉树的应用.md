# 数据结构：树和二叉树的应用

### 1. 树的基本数据结构和操作：

一般在考试之中采用静态写法比较合适，即用数组下标代替所谓的地址。

**结构体node定义：**

```c++
struct node{
	typename data;
    int child[maxn];
}Node[maxn];
```

注意：因为无法预知子结点的个数，child数组长度只能开到最大但是可能导致开辟的空间超出题目的要求限制。因此需要使用c++STL中的vector

```c++
struct node{
	typename data;
	vector child;
}node[maxn];
```

**创建一个新结点：**

```c++
int index=0;
int newNode(int v){
	Node[index].data=v;
	Node[index].child.clear();
	return index++;
}
```

*注意点：*

如果题目中不涉及结点的数据域，即只需要树的结构，那么上面的结构体可以简化为vector数组，即vector<int>

child[maxn]。显然，在这种定义之下，child[0],child[1] ...等中的每一个都是一个vector，存放了各结点所有子结点的下标。

### 2. 树的遍历

**树的先根遍历：**

```c++
void preorder(int root){
	cout<<Node[root].data;
	for(int i=0;i<Node[root].child.size();i++){
		preorder(Node[root].child[i]);
	}
}
```

**树的层序遍历：**（难点，借助队列解决）

使用一个队列来存放结点在数组之中的下标，每次取出队首元素来访问，并且将其余所有子结点加入队列。

```c++
void layerorder(int root){
    queue<int> q;
    q.push(root);
    while(!q.empty()){
        int front=q.front();
        q.pop();
        cout<<Node[front].data;
        for(int i=0;i<Node[front].child.size();i++){
            q.push(Node[front].child[i]);
        }
    }
}
```

如果需要利用结点层号：

```c++
struct node{
	int layer;
	int data;
	vector<int> child;
}

void layerorder(int root){
    queue<int> q;
    q.push(root);
    Node[root].layer=0;
    while(!q.empty()){
        int front=q.front();
        q.pop();
        cout<<Node[front].data;
        for(int i=0;i<Node[front].child.size();i++){
            int child=Node[front].child[i];
            Node[child].layer=Node[front].layer+1;
            q.push(child);
                
        }
    }
}
```

### 3. 二叉查找树的基本操作：

**插入操作：**

```c++
void insert(node* &root,int x){
	if(root==NULL){
		root=newNode(x);
        return;
	}
    if(x==root->data){
        return;
    }else if(x<root->data){
        insert(root-lchild,x);
    }else{
        insert(root->rchild,x);
    }
    
}
```

**二叉查找树的建立：**

```c++
node* create(int data[],int n){
	node* root=NULL;
    for(int i=0;i<n;i++){
        insert(root,data[i]);
    }
    return root;
}
```

**二叉查找树的删除操作**：

![](./pictures/4.jpg)

```c++
void deleteNode(node* &root,int x){
    if(root==NULL) return;
    if(root->data==x){
        if(root->lchild==NULL&&root->rchild==NULL){
            root=NULL;
        }else if(root->lchild!=NULL){
            node* pre=findMax(root->lchild);
            root->data=pre->data;
            deleteNode(root->lchild,pre->data);//左子树之中删除结点pre
        }else{
            node* next=findMin(root->rchild);
            root->data=next->data;
            deleteNode(root->rchild,next->data);
        }
    }else if(root->data>x){
            deleteNode(root->lchild,x);
        }else {
            deleteNode(root->rchild,x);
        }  
}

//寻找以root为根结点的树中的最大权值结点
node* findMax(node* root){
    while(root->rchild!=NULL){
        root->rchild;
    }
    return root;
}

node* findMin(node* root){
    while(root->lchild!=NULL){
        root=root->lchild;
    }
    return root;
}
```

注意总是优先删除前驱会导致树的左右子树高度极度不平衡。解决这一问题可以，记录子树高度，总是优先在高度较高的一颗子树里删除结点。



### 4. 二叉平衡树（AVL树）

**结构体node定义：**

```c++
struct node{
    int v,height;//height为当前子树的高度
    node *lchild,*rchild;
}
```

**创建一个新结点：**

```c++
node *newNode(int v){
	node* Node=new node;
    Node->data=v;
    Node->height=1;
    Node->lchild=Node->rchild=NULL;
    return Node;
}
```

获取当前结点高度：

```c++
int getheight(node* root){
    if(root==NULL) return 0;
    return root->height;
}
```

**计算结点的平衡因子：**

```c++
int getbalanceFactor(node* root){
	return getheight(root->lchild)-getheight(root->rchild);
}
```

注意：

结点root的所在子树的height等于其左子树height与右子树height的较大值加1

**更新高度的函数：**

```c++
void updataHeight(node* root){
    root->height=max(getheight(root->lchild),getheight(root->rchild))+1;
}
```

**插入操作：**

