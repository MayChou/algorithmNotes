# 数据结构：树和二叉树的应用

### 1. 树的基本数据结构和操作：

一般在考试之中采用静态写法比较合适，即用数组下标代替所谓的地址。

**结构体node定义：**

```c++
struct node{
	typename data;
    int child[maxn];
}Node[maxn];
```

注意：因为无法预知子结点的个数，child数组长度只能开到最大但是可能导致开辟的空间超出题目的要求限制。因此需要使用c++STL中的vector

```c++
struct node{
	typename data;
	vector child;
}node[maxn];
```

**创建一个新结点：**

```c++
int index=0;
int newNode(int v){
	Node[index].data=v;
	Node[index].child.clear();
	return index++;
}
```

*注意点：*

如果题目中不涉及结点的数据域，即只需要树的结构，那么上面的结构体可以简化为vector数组，即vector<int>

child[maxn]。显然，在这种定义之下，child[0],child[1] ...等中的每一个都是一个vector，存放了各结点所有子结点的下标。

### 2. 树的遍历

**树的先根遍历：**

```c++
void preorder(int root){
	cout<<Node[root].data;
	for(int i=0;i<Node[root].child.size();i++){
		preorder(Node[root].child[i]);
	}
}
```

**树的层序遍历：**（难点，借助队列解决）

使用一个队列来存放结点在数组之中的下标，每次取出队首元素来访问，并且将其余所有子结点加入队列。

```c++
void layerorder(int root){
    queue<int> q;
    q.push(root);
    while(!q.empty()){
        int front=q.front();
        q.pop();
        cout<<Node[front].data;
        for(int i=0;i<Node[front].child.size();i++){
            q.push(Node[front].child[i]);
        }
    }
}
```

如果需要利用结点层号：

```c++
struct node{
	int layer;
	int data;
	vector<int> child;
}

void layerorder(int root){
    queue<int> q;
    q.push(root);
    Node[root].layer=0;
    while(!q.empty()){
        int front=q.front();
        q.pop();
        cout<<Node[front].data;
        for(int i=0;i<Node[front].child.size();i++){
            int child=Node[front].child[i];
            Node[child].layer=Node[front].layer+1;
            q.push(child);
                
        }
    }
}
```

